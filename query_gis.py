# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QueryGIS
                                 A QGIS plugin
 Contorl GIS with ChatGPT
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-07-07
        git sha              : $Format:%H$
        copyright            : (C) 2025 by 3DLabs, Juseong Lee
        email                : juseonglee99@3dlabs.co.kr / ljsgalaxy246@gmail.com
***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QTimer, QThread, pyqtSignal, QEvent, QVariant, QObject
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QDockWidget, QLineEdit, QWidget, QHBoxLayout, QLabel, QPushButton, QApplication, QTextEdit
from tempfile import gettempdir
import os
from qgis.utils import iface
from qgis.core import QgsApplication, QgsProject, QgsMapLayer, QgsRasterLayer
from openai import OpenAI
from .resources import *
from .dockwidget import Ui_DockWidget
import os.path
import sys
import io

class OpenAIWorker(QThread):
    finished = pyqtSignal(str)
    error = pyqtSignal(str)
    def __init__(self, api_key, user_query, assistant_id):
        super().__init__()
        self.api_key = api_key
        self.user_query = user_query
        self.assistant_id = assistant_id
    def run(self):
        try:
            client = OpenAI(api_key=self.api_key)
            final_query = self.user_query

            thread = client.beta.threads.create(messages=[{"role": "user", "content": f"{final_query}"}])
            run = client.beta.threads.runs.create(thread_id=thread.id, assistant_id=self.assistant_id)
            while run.status != "completed":
                run = client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)
            message_response = client.beta.threads.messages.list(thread_id=thread.id)
            messages = message_response.data
            latest_message = messages[0]
            response = latest_message.content[0].text.value
            if response.startswith("```python"):
                response = response[len("```python"):].strip()
            if response.endswith("```"):
                response = response[:-3].strip()
            self.finished.emit(response)
        except Exception as e:
            self.error.emit(str(e))

class QueryGIS(QObject):
    def __init__(self, iface):
        super().__init__()
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.menu = self.tr(u'&QueryGIS')
        self.actions = []
        self.dockwidget = None  # None으로 초기화
        self.chat_history = []
        self.default_status_color = "#F0F0F0"
        self.success_status_color = "#66FF66"
        self.error_status_color = "#FF3333"

    def tr(self, message):
        return QCoreApplication.translate('QueryGIS', message)
    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True, status_tip=None, whats_this=None, parent=None):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        if status_tip is not None:
            action.setStatusTip(status_tip)
        if whats_this is not None:
            action.setWhatsThis(whats_this)
        if add_to_toolbar:
            self.iface.addToolBarIcon(action)
        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)
        self.actions.append(action)
        return action
    def initGui(self):
        icon_path = ':/plugins/query_gis/icon.png'
        self.add_action(icon_path, text=self.tr(u'QueryGIS'), callback=self.run, parent=self.iface.mainWindow())
    def unload(self):
        if self.dockwidget:
            self.iface.removeDockWidget(self.dockwidget)
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&QueryGIS'), action)
            self.iface.removeToolBarIcon(action)
    def run(self):
        if not self.dockwidget:
            self.dockwidget = QDockWidget("QueryGIS", self.iface.mainWindow())
            self.dockwidget.setAttribute(Qt.WA_DeleteOnClose, True)
            self.dockwidget.setObjectName("QueryGISDockWidget")
            # 삭제 시 self.dockwidget을 None으로 갱신
            self.dockwidget.destroyed.connect(lambda: setattr(self, 'dockwidget', None))
            self.ui = Ui_DockWidget()
            self.ui.setupUi(self.dockwidget)
            self.ui.line_apikey.setEchoMode(QLineEdit.Password)
            self.ui.btn_ask.clicked.connect(self.process_query)
            self.ui.chk_ask_run.stateChanged.connect(self.toggle_ask_run)
            self.ui.text_query.installEventFilter(self)
            self.ui.status_label.setStyleSheet(f"background-color: {self.default_status_color}; color: black;")
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.ui.chk_ask_run.setChecked(True)
            self.ui.chk_reason.setChecked(True)
            self.ui.chk_rag.setChecked(False)
        self.dockwidget.show()
    def eventFilter(self, obj, event):
        if obj == self.ui.text_query and event.type() == QEvent.KeyPress:
            if event.key() == Qt.Key_Return and event.modifiers() == Qt.ControlModifier:
                self.process_query()
                return True
        return False
    def toggle_ask_run(self):
        if self.ui.chk_ask_run.isChecked():
            self.ui.btn_ask.setText("Ask and Run\n(Ctrl+Enter)")
        else:
            self.ui.btn_ask.setText("Ask\n(Ctrl+Enter)")
    def add_chat_message(self, role, message):
        msg_widget = QWidget()
        layout = QHBoxLayout(msg_widget)
        layout.setContentsMargins(10, 5, 10, 5)
        
        if role == "user":
            # 사용자 메시지는 QLabel 유지, 드래그 가능하게 설정
            label = QLabel(message)
            label.setWordWrap(True)
            label.setTextInteractionFlags(Qt.TextSelectableByMouse)  # 텍스트 드래그 가능
            label.setStyleSheet("background-color: #1AC85C; color: white; border: none; border-radius: 10px; padding: 8px; font-family: '맑은 고딕'; font-size: 12px;")
            layout.addStretch()
            layout.addWidget(label)
        elif role == "assistant-print":
            # 봇 메시지는 QLabel 유지, 드래그 가능하게 설정
            label = QLabel(message)
            label.setWordWrap(True)
            label.setTextInteractionFlags(Qt.TextSelectableByMouse)
            label.setStyleSheet("background-color: #D9D9D9; color: black; border: none; border-radius: 10px; padding: 8px;")
            
            layout.addWidget(label)
            copy_btn = QPushButton("Copy")
            copy_btn.setMaximumSize(40, 25)
            copy_btn.clicked.connect(lambda _, edit=label: self.copy_to_clipboard(edit.text()))
            layout.addWidget(copy_btn)
            layout.addStretch()
        else:
            # 봇 메시지는 QTextEdit으로 변경하여 수정 가능하게 설정
            text_edit = QTextEdit()
            text_edit.setPlainText(message)  # 일반 텍스트로 설정
            text_edit.setReadOnly(False)  # 수정 가능하게 설정
            
            # 문서 크기에 따라 자동으로 확장되도록 설정
            text_edit.document().documentLayout().documentSizeChanged.connect(
                lambda size: text_edit.setMinimumHeight(int(size.height()) + 20)
            )
            
            # 초기 높이 설정
            text_edit.setMinimumHeight(int(text_edit.document().size().height()) + 20)
            
            # 스타일 설정
            text_edit.setStyleSheet("""
                QTextEdit {
                    background-color: #D9D9D9; 
                    color: black; 
                    border: none; 
                    border-radius: 10px; 
                    padding: 8px;
                }
            """)
            
            # 스크롤바 비활성화
            text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            
            layout.addWidget(text_edit)
            run_btn = QPushButton("Run")
            run_btn.setMaximumSize(40, 25)
            layout.addWidget(run_btn)
            copy_btn = QPushButton("Copy")
            copy_btn.setMaximumSize(40, 25)
            layout.addWidget(copy_btn)
            layout.addStretch()
            
            # 버튼 이벤트 연결 (텍스트 에디트의 현재 내용을 가져오도록 수정)
            run_btn.clicked.connect(lambda _, edit=text_edit: self.run_message(edit.toPlainText()))
            copy_btn.clicked.connect(lambda _, edit=text_edit: self.copy_to_clipboard(edit.toPlainText()))
        
        return msg_widget
    def append_chat_message(self, role, message):
        self.chat_history.append({"role": role, "content": message})
        msg_widget = self.add_chat_message(role, message)
        self.ui.chatLayout.insertWidget(self.ui.chatLayout.count() - 1, msg_widget)
        
        # 사용자 메시지가 추가될 때 상태 색상을 기본으로 초기화
        if role == "user":
            self.ui.status_label.setStyleSheet(f"background-color: {self.default_status_color}; color: black;")
        
        # Increase the delay to ensure the UI has time to update
        QTimer.singleShot(100, self.scroll_to_bottom)

    def scroll_to_bottom(self):
        # Force layout update before scrolling
        QApplication.processEvents()
        scrollbar = self.ui.chatScrollArea.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    def copy_to_clipboard(self, text):
        clipboard = QApplication.clipboard()
        clipboard.setText(text)
    def run_message(self, code):
        try:
            old_stdout = sys.stdout
            sys.stdout = io.StringIO()
            exec(code)
            output = sys.stdout.getvalue().strip()
            sys.stdout = old_stdout
            self.ui.status_label.setText("Status: Code Execution Succeed.")
            self.ui.status_label.setStyleSheet(f"background-color: {self.success_status_color}; color: black;")
            if output:
                self.append_chat_message("assistant-print", output)
        except Exception as e:
            self.ui.status_label.setText("Something Wrong:\n" + str(e))
            self.ui.status_label.setStyleSheet(f"background-color: {self.error_status_color}; color: white;")
    def process_query(self):
        # 새로운 쿼리가 시작될 때 상태 색상을 기본으로 초기화
        self.ui.status_label.setText("Processing query...")
        self.ui.status_label.setStyleSheet(f"background-color: {self.default_status_color}; color: black;")
        
        api_key = self.ui.line_apikey.text().strip()
        user_input = self.ui.text_query.toPlainText().strip()
        if not api_key:
            self.ui.status_label.setText("API Key is missing!")
            self.ui.status_label.setStyleSheet(f"background-color: {self.error_status_color}; color: white;")
            self.ui.btn_ask.setEnabled(True)
            return
        if not user_input:
            self.ui.status_label.setText("Query is empty!")
            self.ui.status_label.setStyleSheet(f"background-color: {self.error_status_color}; color: white;")
            self.ui.btn_ask.setEnabled(True)
            return
        self.append_chat_message("user", user_input)
        self.ui.text_query.clear()
        project = QgsProject.instance()
        project_info = {
            "title": project.title(),
            "fileName": project.fileName(),
            "layerCount": len(project.mapLayers()),
            "crs": project.crs().authid(),
            "distanceUnits": project.distanceUnits(),
            "areaUnits": project.areaUnits(),
            "homePath": project.homePath(),
        }
        layers_info = []
        for layer_id, layer in project.mapLayers().items():
            layer_info = {
                "name": layer.name(),
                "id": layer_id,
                "type": layer.type(),
                "crs": layer.crs().authid(),
                "featureCount": layer.featureCount() if layer.type() == QgsMapLayer.VectorLayer else "N/A",
                "provider": layer.dataProvider().name(),
                "extent": layer.extent().toString(),
                "opacity": layer.opacity(),
                "source": layer.source()
            }
            if layer.type() == QgsMapLayer.VectorLayer:
                fields_info = []
                for field in layer.fields():
                    fields_info.append({"name": field.name(), "type": field.typeName()})
                layer_info["fields"] = fields_info
                layer_info["isEditable"] = layer.isEditable()
                layer_info["selectedFeatureCount"] = len(layer.selectedFeatures())
            elif layer.type() == QgsMapLayer.RasterLayer:
                rlayer = QgsRasterLayer(layer.source(), layer.name(), layer.providerType())
                if rlayer.isValid():
                    layer_info["pixelSizeX"] = rlayer.rasterUnitsPerPixelX()
                    layer_info["pixelSizeY"] = rlayer.rasterUnitsPerPixelY()
                    layer_info["width"] = rlayer.width()
                    layer_info["height"] = rlayer.height()
                    layer_info["bandCount"] = rlayer.bandCount()
            layers_info.append(layer_info)
        active_layer = iface.activeLayer()
        active_layer_info = None
        if active_layer:
            active_layer_info = {
                "name": active_layer.name(),
                "id": active_layer.id(),
                "type": active_layer.type(),
                "crs": active_layer.crs().authid(),
                "featureCount": active_layer.featureCount() if active_layer.type() == QgsMapLayer.VectorLayer else "N/A",
                "provider": active_layer.dataProvider().name(),
                "extent": active_layer.extent().toString(),
                "opacity": active_layer.opacity(),
                "source": active_layer.source()
            }
            if active_layer.type() == QgsMapLayer.VectorLayer:
                fields_info = []
                for field in active_layer.fields():
                    fields_info.append({"name": field.name(), "type": field.typeName()})
                active_layer_info["fields"] = fields_info
                active_layer_info["isEditable"] = active_layer.isEditable()
                active_layer_info["selectedFeatureCount"] = len(active_layer.selectedFeatures())
            elif active_layer.type() == QgsMapLayer.RasterLayer:
                rlayer = QgsRasterLayer(active_layer.source(), active_layer.name(), active_layer.providerType())
                if rlayer.isValid():
                    active_layer_info["pixelSizeX"] = rlayer.rasterUnitsPerPixelX()
                    active_layer_info["pixelSizeY"] = rlayer.rasterUnitsPerPixelY()
                    active_layer_info["width"] = rlayer.width()
                    active_layer_info["height"] = rlayer.height()
                    active_layer_info["bandCount"] = rlayer.bandCount()
        # 현재 맵 캔버스의 확장 영역 가져오기
        map_canvas = iface.mapCanvas()
        visible_extent = map_canvas.extent()

        # 현재 보고 있는 영역 정보
        current_view_info = {
            "xMin": visible_extent.xMinimum(),
            "yMin": visible_extent.yMinimum(),
            "xMax": visible_extent.xMaximum(),
            "yMax": visible_extent.yMaximum(),
            "width": visible_extent.width(),
            "height": visible_extent.height(),
            "center": {
                "x": visible_extent.center().x(),
                "y": visible_extent.center().y()
            },
            "scale": map_canvas.scale(),
            "rotation": map_canvas.rotation()
        }

        full_query = "현재 프로젝트, 프로젝트 내의 모든 레이어, 현재 선택된 레이어, 현재 보고있는 영역에 대한 정보를 먼저 알려줄게.\n"
        full_query += "======== Project Info ========\n"
        for key, value in project_info.items():
            full_query += f"  {key}: {value}\n"
        full_query += "\n======== Layers Info ========\n"
        for layer_info in layers_info:
            full_query += f"  Layer Name: {layer_info['name']}\n"
            for key, value in layer_info.items():
                if key != "name":
                    full_query += f"    {key}: {value}\n"
            full_query += "  ----------------------\n"
        full_query += "\n======== Active Layer Info ========\n"
        if active_layer_info:
            for key, value in active_layer_info.items():
                full_query += f"  {key}: {value}\n"
        else:
            full_query += "  No active layer selected.\n"
        full_query += "\n======== Current View Info ========\n"
        for key, value in current_view_info.items():
            full_query += f"  {key}: {value}\n"
        full_query += "And the User's Request is : " + user_input + "\n"
        full_query += "그리고, 항상 모든 명령에 '이 레이어' 나 '이 shp 파일' 처럼 이름을 명명하지 않는다면, activeLayer() 함수를 통해서 사용자의 말을 알아내. 모든 과정에서 새롭게 생성되는 모든 shp 파일 및 레이어는 사용자가 명명하지 않는 이상 모두 temp에 저장해. 그리고 코드를 작성할 때는 항상 견고하지만 이해하기 쉽게 작성하고, 가장 간단하게 목표를 이룰 수 있도록 작성해. 제일 중요한건, 각 코드에서 필요한 객체를 import 해야 한다면, 꼭 import 를 명시해줘. 주석은 절대로 달지마. 기본적으로 항상 새로운 레이어를 생성하여 작업해줘. 레이어를 합성하기 위해 'gdal:buildvirtualraster' 기능을 사용할 때는, 꼭!!!! 'PROJ_DIFFERENCE': True 코드를 써줘. 만약 래스터 계산을 한다고 할 때, 'native:rastercalculator'를 사용하지말고 'native:rastercalc' 이 기능을 꼭 써서 작성해줘 그리고 from qgis.core import *,from qgis.gui import *, from qgis.analysis import *, from qgis.processing import *, from qgis.utils import *,from PyQt5.QtCore import *, from PyQt5.QtGui import *,import processing 이 import 문들은 이미 입력되었으니까 쓰지마. 제일 중요한건 코드 외의 어떤 말도 필요없어. 폴리곤 툴을 다룰 때는 각 폴리곤이 무결하지 않을 수 있다는 것을 염두해두고 작업해."
        # print(full_query)
        self.loading = True
        self.loading_index = 0
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_loading_text)
        self.timer.start(300)
        print(f"chk_reason checked : {self.ui.chk_reason.isChecked()}")
        print(f"chk_rag checked : {self.ui.chk_rag.isChecked()}")
        if self.ui.chk_reason.isChecked():
            assistant_id = "asst_lBgX9ATTPMf7EezudLcMKi3j"
            print("Reasoning On")
            if self.ui.chk_rag.isChecked():
                assistant_id = "asst_XPKTu0WFqp57sjzhSvRy4hcf"
                print("RAG on")
        else:
            assistant_id = "asst_PVAKCFkZJErndnUvjXFwxATK"
            print("Reasoning Off")
            if self.ui.chk_rag.isChecked():
                assistant_id = "asst_bkccSq0rhMUkeIHFwParQ1G7"
                print("RAG on")
        print("Assistant ID: ", assistant_id)
        self.worker = OpenAIWorker(api_key, full_query, assistant_id)
        self.worker.finished.connect(self.handle_response)
        self.worker.error.connect(self.handle_error)
        self.worker.start()
    def update_loading_text(self):
        if not self.loading:
            return
        loading_texts = ["Loading.", "Loading..", "Loading...", "Loading."]
        self.ui.status_label.setText(loading_texts[self.loading_index])
        # 로딩 중에는 기본 색상 유지
        self.ui.status_label.setStyleSheet(f"background-color: {self.default_status_color}; color: black;")
        self.loading_index = (self.loading_index + 1) % len(loading_texts)
    def handle_response(self, response):
        self.timer.stop()
        self.loading = False
        self.ui.btn_ask.setEnabled(True)
        # 응답 처리가 완료되면 기본 상태로 복귀
        self.ui.status_label.setText("Response received.")
        self.ui.status_label.setStyleSheet(f"background-color: {self.default_status_color}; color: black;")
        add_imports = ("from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\n"
                       "from qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\n"
                       "from PyQt5.QtGui import *\nimport processing\n")
        response = add_imports + response
        self.append_chat_message("assistant", response)
        if self.ui.chk_ask_run.isChecked():
            self.run_message(response)
    def handle_error(self, error_message):
        self.timer.stop()
        self.loading = False
        # 오류 발생 시 빨간색으로 변경
        self.ui.status_label.setText(f"Error: {error_message}")
        self.ui.status_label.setStyleSheet(f"background-color: {self.error_status_color}; color: white;")
    def run_response(self):
        if not self.chat_history:
            self.ui.status_label.setText("Status: No code to execute.")
            self.ui.status_label.setStyleSheet(f"background-color: {self.error_status_color}; color: white;")
            return
        last_msg = self.chat_history[-1]
        if last_msg["role"] != "assistant":
            self.ui.status_label.setText("Status: Last message is not code.")
            self.ui.status_label.setStyleSheet(f"background-color: {self.error_status_color}; color: white;")
            return
        self.run_message(last_msg["content"])