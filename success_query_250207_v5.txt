[
  {
    "request": "지금 이 레이어는 여러개의 featrue 가 저장되어있어. 각각의 폴리곤을 각각 shp 파일로 저장해줘.",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom qgis.core import QgsProject, QgsVectorLayer, QgsFeatureRequest, QgsVectorFileWriter, QgsWkbTypes\nimport processing\n\n# Get the active layer\nlayer = iface.activeLayer()\n\n# Check if the layer is a polygon layer\nif layer.geometryType() == QgsWkbTypes.PolygonGeometry:\n    \n    # Iterate over each feature in the active layer\n    for feature in layer.getFeatures():\n        \n        # Create a new memory layer for each feature\n        memory_layer = QgsVectorLayer(\"Polygon?crs={}\".format(layer.crs().authid()), \n                                      \"Feature_{}\".format(feature.id()), \n                                      \"memory\")\n        \n        # Start editing the memory layer\n        memory_layer.startEditing()\n        \n        # Add fields from the original layer\n        memory_layer.dataProvider().addAttributes(layer.fields())\n        memory_layer.updateFields()\n        \n        # Add the current feature to the new memory layer\n        memory_layer.dataProvider().addFeature(feature)\n        \n        # Stop editing and commit changes\n        memory_layer.commitChanges()\n        \n        # Add the new layer to the current project\n        QgsProject.instance().addMapLayer(memory_layer)\n\nelse:\n    print(\"The active layer is not a polygon layer.\")"
  },
  {
    "request": "이 레이어에서 CTP_ENG_NM 칼럼이 Incheon인 폴리곤을 새로운 레이어로 추출해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom qgis.core import QgsProject\nfrom qgis.core import QgsVectorLayer\n\n# Get the active layer\nlayer = iface.activeLayer()\n\n# Ensure the layer is valid\nif layer is not None and layer.isValid():\n\n    # Define the filter expression\n    expression = '\"CTP_ENG_NM\" = \\'Incheon\\''\n\n    # Use QgsFeatureRequest to filter features\n    request = QgsFeatureRequest()\n    request.setFilterExpression(expression)\n\n    # Create a memory layer for the output\n    output_layer = QgsVectorLayer('Polygon?crs=' + layer.crs().toWkt(), 'Filtered_Incheon', 'memory')\n    output_provider = output_layer.dataProvider()\n\n    # Add fields from the original layer to the new layer\n    output_provider.addAttributes(layer.fields())\n    output_layer.updateFields()\n\n    # Use a feature iterator with the filter\n    features = layer.getFeatures(request)\n    for feature in features:\n        output_provider.addFeature(feature)\n\n    # Add the new layer to the project\n    QgsProject.instance().addMapLayer(output_layer)"
  },
  {
    "request": "A라는 이름의 레이어와 B라는 이름의 레이어 두 개는 모두 폴리곤 feature야. 이 두 레이어를 병합해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nimport processing\nfrom qgis.core import QgsProject\n\n# Get the layers by their name\nlayer_a = QgsProject.instance().mapLayersByName('A')[0]\nlayer_b = QgsProject.instance().mapLayersByName('B')[0]\n\n# Merge the layers\nmerged_layer_output = processing.run(\"native:mergevectorlayers\", {\n    'LAYERS': [layer_a, layer_b],\n    'CRS': layer_a.crs(),\n    'OUTPUT': 'memory:'  # Save the output to memory\n})['OUTPUT']\n\n# Add the merged layer to the project\nQgsProject.instance().addMapLayer(merged_layer_output)"
  },
  {
    "request": "이 레이어의 좌표계를 EPSG:5174 로 지정하고 싶어! 지정해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom qgis.core import QgsProject, QgsCoordinateReferenceSystem\nfrom qgis.utils import iface\n\n# Get the active layer\nlayer = iface.activeLayer()\n\n# Check if the layer is valid\nif not layer:\n    print(\"No active layer selected.\")\nelse:\n    # Set the CRS to EPSG:5174\n    crs = QgsCoordinateReferenceSystem(\"EPSG:5174\")\n    layer.setCrs(crs)\n\n    # Refresh the layer to apply changes\n    layer.triggerRepaint()\n\n    # Add the layer to the project if not already added\n    if not QgsProject.instance().mapLayersByName(layer.name()):\n        QgsProject.instance().addMapLayer(layer)"
  },
  {
    "request": "Incheon 레이어를 NamGu 레이어로 clip 해줄래??",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom qgis.core import QgsProject, QgsVectorLayer\nimport processing\n\n# Fetch the map layers by name\nincheon_layer = QgsProject.instance().mapLayersByName(\"Incheon\")[0]\nnamgu_layer = QgsProject.instance().mapLayersByName(\"NamGu\")[0]\n\n# Run the clip process\nclip_result = processing.run(\"native:clip\", {\n    'INPUT': incheon_layer,\n    'OVERLAY': namgu_layer,\n    'OUTPUT': 'memory:'  # Save the results in memory\n})\n\n# Add the clipped layer to the project\nclipped_layer = clip_result['OUTPUT']\nQgsProject.instance().addMapLayer(clipped_layer)"
  },
  {
    "request": "ctprvn 레이어에는 여러개의 폴리곤 feature 가 있어. 각 폴리곤 내부 중심에 포인트 feature를 생성하여 새로운 레이어를 만들어줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nlayer = iface.activeLayer()\n\nif not layer:\n    print(\"No active layer found.\")\nelse:\n    centroids = [feature.geometry().centroid() for feature in layer.getFeatures()]\n\n    point_fields = QgsFields()\n    for field in layer.fields():\n        point_fields.append(field)\n\n    point_layer = QgsVectorLayer(\"Point?crs=EPSG:4326\", \"Centroids\", \"memory\")\n    point_layer_data = point_layer.dataProvider()\n\n    point_layer_data.addAttributes(point_fields)\n    point_layer.updateFields()\n\n    point_features = []\n    for feature in layer.getFeatures():\n        point_feature = QgsFeature()\n        point_feature.setGeometry(feature.geometry().centroid())\n        point_feature.setAttributes(feature.attributes())\n        point_features.append(point_feature)\n\n    point_layer_data.addFeatures(point_features)\n    QgsProject.instance().addMapLayer(point_layer)"
  },
  {
    "request": "ctprvn 레이어의 이름을 abcd 로 변환해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nlayer = None\nproject = QgsProject.instance()\nfor lyr in project.mapLayers().values():\n    if lyr.name() == 'ctprvn':\n        layer = lyr\n        break\n\nif layer:\n    layer.setName('abcd')\n    project.addMapLayer(layer)"
  },
  {
    "request": "pp 레이어에 있는 각 포인트들에 거리 1000씩 버퍼를 적용해서 새로운 레이어를 만들어줘.",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nimport processing\n\nlayer = QgsProject.instance().mapLayersByName('pp')[0]\n\nbuffer_output = processing.run(\"native:buffer\", {\n    'INPUT': layer,\n    'DISTANCE': 1000,\n    'SEGMENTS': 5,\n    'END_CAP_STYLE': 0,\n    'JOIN_STYLE': 0,\n    'MITER_LIMIT': 2,\n    'DISSOLVE': False,\n    'OUTPUT': 'memory:'\n})\n\nbuffer_layer = buffer_output['OUTPUT']\nQgsProject.instance().addMapLayer(buffer_layer)"
  },
  {
    "request": "pp 레이어에 있는 포인트 feature들을 모두 연결하는 line 레이어를 생성해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\n# Get the active point layer from the user\npoint_layer = iface.activeLayer()\n\n# Connect all features with a line\nline_features = []\nfeature_points = []\n\nfor feature in point_layer.getFeatures():\n    geom = feature.geometry()\n    if geom.isMultipart():\n        # Handle multipart geometries\n        for part in geom.asMultiPoint():\n            feature_points.append(part)\n    else:\n        feature_points.append(geom.asPoint())\n\nif feature_points:\n    polyline = QgsGeometry.fromPolylineXY(feature_points)\n    line_feature = QgsFeature()\n    line_feature.setGeometry(polyline)\n    line_features.append(line_feature)\n\n# Create a temporary line layer in memory\nline_layer = QgsVectorLayer(\"LineString?crs=\" + point_layer.crs().authid(), \"Connected Lines\", \"memory\")\nline_layer_data_provider = line_layer.dataProvider()\nline_layer_data_provider.addFeatures(line_features)\n\nQgsProject.instance().addMapLayer(line_layer)"
  },
  {
    "request": "ab 레이어에 있는 폴리곤 feature를 line feature로 변환해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nlayer = iface.activeLayer()\nif layer is None:\n    quit()\n\nimport processing\nfrom qgis.core import QgsProject\n\nparams = {\n    'INPUT': layer,\n    'OUTPUT': 'memory:'\n}\n\nline_layer = processing.run('native:polygonstolines', params)['OUTPUT']\n\nQgsProject.instance().addMapLayer(line_layer)"
  },
  {
    "request": "Incheon 레이어의 모든 폴리곤을 하나로 병합하여 새로운 레이어를 만들어줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nfrom qgis.core import QgsVectorLayer, QgsProject\nimport processing\n\n# 현재 활성 레이어 가져오기\nlayer = iface.activeLayer()\n\n# 'Incheon' 레이어가 맞는지 확인\nif layer.name() == \"Incheon\":\n    # 모든 폴리곤을 하나로 병합\n    dissolved_layer = processing.run(\"native:dissolve\", {\n        'INPUT': layer,\n        'OUTPUT': 'memory:'\n    })['OUTPUT']\n\n    # 새 레이어를 프로젝트에 추가\n    QgsProject.instance().addMapLayer(dissolved_layer)"
  },
  {
    "request": "output 레이어에서 NamGu 레이어의 영역 만큼 잘라서 새로운 레이어로 만들어줄래?:",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nimport processing\n\nactive_layer = iface.activeLayer()\nnamgu_layer = None\nfor layer in QgsProject.instance().mapLayers().values():\n    if \"NamGu\" in layer.name():\n        namgu_layer = layer\n        break\n\nif active_layer is None or namgu_layer is None:\n    raise ValueError(\"Required layers are not found.\")\n\nparams = {\n    'INPUT': active_layer,\n    'OVERLAY': namgu_layer,\n    'OUTPUT': 'memory:'\n}\n\noutput = processing.run(\"native:clip\", params)['OUTPUT']\nQgsProject.instance().addMapLayer(output)"
  },
  {
    "request": "Incheon 레이어의 각 폴리곤 feature를 Count 속성값 50을 기준으로 분류하여 색을 다르게 지정해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\n\nlayer = iface.activeLayer() if iface.activeLayer().name() == 'Incheon' else None\n\nif layer:\n    categories = []\n    for unique_value in layer.uniqueValues(layer.fields().indexOf('Count')):\n        if unique_value <= 50:\n            symbol = QgsSymbol.defaultSymbol(layer.geometryType())\n            symbol.setColor(QColor(255, 0, 0))  # Red for Count <= 50\n        else:\n            symbol = QgsSymbol.defaultSymbol(layer.geometryType())\n            symbol.setColor(QColor(0, 255, 0))  # Green for Count > 50\n        category = QgsRendererCategory(unique_value, symbol, str(unique_value))\n        categories.append(category)\n\n    renderer = QgsCategorizedSymbolRenderer('Count', categories)\n    layer.setRenderer(renderer)\n    layer.triggerRepaint()\n    iface.layerTreeView().refreshLayerSymbology(layer.id())"
  },
  {
    "request": "Incheon 레이어에 있는 각 폴리곤 feature 내에 Factory 레이어의 포인트 feature가 각각 몇개가 있는지 count 해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nincheon_layer = None\nfactory_layer = None\n\nfor layer in QgsProject.instance().mapLayers().values():\n    if 'Incheon' in layer.name():\n        incheon_layer = layer\n    elif 'Factory' in layer.name():\n        factory_layer = layer\n\nif not incheon_layer or not factory_layer:\n    raise Exception(\"Either 'Incheon' or 'Factory' layer is not found.\")\n\nprocessing.run(\"native:countpointsinpolygon\", {\n    'POLYGONS': incheon_layer, \n    'POINTS': factory_layer, \n    'CLASSFIELD': '', \n    'COUNTFIELD': 'factory_count', \n    'OUTPUT': 'memory:'\n})\n\nalg_result = processing.run(\"native:countpointsinpolygon\", {\n    'POLYGONS': incheon_layer,\n    'POINTS': factory_layer,\n    'CLASSFIELD': '',\n    'COUNTFIELD': 'factory_count',\n    'OUTPUT': 'memory:'\n})\n\ncount_layer = alg_result['OUTPUT']\nQgsProject.instance().addMapLayer(count_layer)"
  },
  {
    "request": "Road 레이어에서 AREA 속성값이 1000 이하인 폴리곤만 새로 추출해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nlayer = iface.activeLayer()\n\nif not layer:\n    print(\"활성 레이어가 없습니다.\")\nelse:    \n    query = '\"AREA\" <= 1000'\n    \n    selected_layer = processing.run(\"native:extractbyexpression\", {\n        'INPUT': layer,\n        'EXPRESSION': query,\n        'OUTPUT': 'memory:'\n    })['OUTPUT']\n    \n    QgsProject.instance().addMapLayer(selected_layer)"
  },
  {
    "request": "NamGu 레이어와교차되는 Factory 레이어의 포인트들을 추출해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nnamgu_layer = None\nfactory_layer = None\n\nfor layer in QgsProject.instance().mapLayers().values():\n    if 'NamGu' in layer.name():\n        namgu_layer = layer\n    elif 'Factory' in layer.name():\n        factory_layer = layer\n\nif namgu_layer and factory_layer:\n    params = {\n        'INPUT': factory_layer,\n        'PREDICATE': [0],  # Intersects\n        'INTERSECT': namgu_layer,\n        'OUTPUT': 'memory:IntersectedPoints'\n    }\n    result = processing.run(\"native:extractbylocation\", params)\n    intersected_points_layer = result['OUTPUT']\n    QgsProject.instance().addMapLayer(intersected_points_layer)"
  },
  {
    "request": "Road 레이어의 폴리곤 feature를 라인 feature로 바꿔줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nlayer = iface.activeLayer()\n\nif layer is None:\n    raise Exception(\"No active layer found\")\n\nif layer.name() == 'Road':\n    line_layer = QgsVectorLayer(\"LineString?crs=\" + layer.crs().authid(), \"Road_Lines\", \"memory\")\n    \n    line_fields = line_layer.dataProvider().fields()\n    line_layer.dataProvider().addAttributes(line_fields)\n    line_layer.updateFields()\n\n    features = layer.getFeatures()\n\n    for feature in features:\n        geom = feature.geometry()\n        if geom.isMultipart():\n            multiline = geom.asMultiPolygon()\n            for part in multiline:\n                for polyline in part:\n                    line_feature = QgsFeature(line_fields)\n                    line_feature.setGeometry(QgsGeometry.fromPolylineXY(polyline))\n                    line_feature.setAttributes(feature.attributes())\n                    line_layer.dataProvider().addFeatures([line_feature])\n        else:\n            polygon = geom.asPolygon()\n            for polyline in polygon:\n                line_feature = QgsFeature(line_fields)\n                line_feature.setGeometry(QgsGeometry.fromPolylineXY(polyline))\n                line_feature.setAttributes(feature.attributes())\n                line_layer.dataProvider().addFeatures([line_feature])\n\n    QgsProject.instance().addMapLayer(line_layer)\nelse:\n    raise Exception(\"The active layer is not named 'Road'\")"
  },
  {
    "request": "이 레이어에는 여러개의 feature 가 있어. \n각각의 feature 를 각각의 레이어로 저장해줘. \n이름은 각각의 feature 의 \"시군구\" 속성으로 해줘.\n아마 남구, 동구 이런식의 이름이 있을거야.",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nlayer = iface.activeLayer()\nfeatures = layer.getFeatures()\nfield_name = '시군구'\n\nunique_values = layer.uniqueValues(layer.fields().indexOf(field_name))\n\nfor value in unique_values:\n    expr = f'\"{field_name}\" = \\'{value}\\''\n    subset_layer = layer.materialize(QgsFeatureRequest().setFilterExpression(expr))\n    subset_layer.setName(value)\n    QgsProject.instance().addMapLayer(subset_layer)"
  },
  {
    "request": "지금 나한테는 세개의 tif 파일 레이어가 있어.\n\n각각 모두 프로젝트에 올라와있어. \n\n이름은 다음과 같아:\nL3A_202312260087_20230808_37612078_N\nL3A_202312260087_20230808_37612078_G\nL3A_202312260087_20230808_37612078_B\n\n각각의 영상은 위성으로 촬영한 원본 tif 파일인데, 이 세개를 각각 병합해서 컬러영상을 저장하고싶어. \nL3A_202312260087_20230808_37612078_N는 Red 밴드,\nL3A_202312260087_20230808_37612078_G는 Green 밴드,\nL3A_202312260087_20230808_37612078_B는 Blue 밴드로 설정할거야.\n\n각 입력파일을 각각의 밴드로 배치할거야.\n\n레스터 병합 기능을 사용하고, 각각 R, G, B 밴드로 적용해서 합성한 다음 컬러 영상으로 나타나게 해줘.\n\n그리고 합성한 결과는 레이어에 추가해서 바로 볼 수 있게 해줘.  \n\ngdal:buildvirtualraster 기능을 사용해서 구현해줘\n\n그리고 코드를 작성할 때는 항상 견고하지만, 가장 간단하게 목표를 이룰 수 있도록 작성할 수 있도록 해줘.\n\n간단하게라는 말은 짧게가 아니라, 이해하기 쉽게라는 뜻이야.\n\n인터넷 검색을 통해 이럴 경우 어떤 코드를 사용하는지 하며 double check 를 해줘.",
    "response": "from qgis.core import (\n    QgsProject, \n    QgsProcessingFeatureSourceDefinition\n)\nimport processing\n\n# 각 tif 레이어 이름을 지정합니다.\nred_band_layer = 'L3A_202312260087_20230808_37612078_N'\ngreen_band_layer = 'L3A_202312260087_20230808_37612078_G'\nblue_band_layer = 'L3A_202312260087_20230808_37612078_B'\n\n# 프로젝트에서 해당 레이어를 가져옵니다.\nred_layer = QgsProject.instance().mapLayersByName(red_band_layer)[0]\ngreen_layer = QgsProject.instance().mapLayersByName(green_band_layer)[0]\nblue_layer = QgsProject.instance().mapLayersByName(blue_band_layer)[0]\n\n# 레이어의 파일 경로를 가져옵니다.\nred_path = red_layer.dataProvider().dataSourceUri().split(\"|\")[0]\ngreen_path = green_layer.dataProvider().dataSourceUri().split(\"|\")[0]\nblue_path = blue_layer.dataProvider().dataSourceUri().split(\"|\")[0]\n\n# gdal:buildvirtualraster를 이용하여 레스터를 병합합니다.\noutput_path = 'memory:merged_color_composite.vrt'\n\nprocessing.run(\"gdal:buildvirtualraster\", {\n    'INPUT': [red_path, green_path, blue_path],\n    'RESOLUTION': 0,  # 가장 잘 맞는 해상도를 선택합니다.\n    'SEPARATE': True,  # 밴드별로 분리합니다.\n    'OUTPUT': output_path\n})\n\n# 병합 결과를 프로젝트에 추가합니다.\nresult_layer = QgsRasterLayer(output_path, 'Color Composite')\nif result_layer.isValid():\n    QgsProject.instance().addMapLayer(result_layer)\nelse:\n    print(\"결과 레이어를 불러오지 못했습니다.\")"
  },
  {
    "request": "지금 나한테는 세개의 tif 파일 레이어가 있어.\n\n각각 모두 프로젝트에 올라와있어. \n\n이름은 다음과 같아:\nL3A_202312260087_20230808_37612078_R\nL3A_202312260087_20230808_37612078_G\nL3A_202312260087_20230808_37612078_B\n\n각각의 영상은 위성으로 촬영한 원본 tif 파일인데, 이 세개를 각각 병합해서 컬러영상을 저장하고싶어. \nL3A_202312260087_20230808_37612078_R는 Red 밴드,\nL3A_202312260087_20230808_37612078_G는 Green 밴드,\nL3A_202312260087_20230808_37612078_B는 Blue 밴드로 설정할거야.\n\n각 입력파일을 개별 밴드로 배치할거야.\n\n레스터 병합 기능을 사용하고, 각각 R, G, B 밴드로 적용해서 합성한 다음 컬러 영상으로 나타나게 해줘.\n\n그리고 합성한 결과는 레이어에 추가해서 바로 볼 수 있게 해줘. \n\n이전에 발생한 오류를 말해줄테니, 오류가 발생하지 않도록 조심해서 코드를 작성해줘\nTraceback (most recent call last):\n  File \"C:\\PROGRA~1\\QGIS33~1.3\\apps\\Python312\\Lib\\code.py\", line 90, in runcode\n    exec(code, self.locals)\n  File \"<input>\", line 1, in <module>\n  File \"<string>\", line 25, in <module>\n  File \"C:\\PROGRA~1/QGIS33~1.3/apps/qgis/./python/plugins\\processing\\tools\\general.py\", line 109, in run\n    return Processing.runAlgorithm(algOrName, parameters, onFinish, feedback, context)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\PROGRA~1/QGIS33~1.3/apps/qgis/./python/plugins\\processing\\core\\Processing.py\", line 174, in runAlgorithm\n    raise QgsProcessingException(msg)\n_core.QgsProcessingException: 오류: gdal:buildvrt 알고리즘을 찾을 수 없습니다",
    "response": "from qgis.core import (\n    QgsProject,\n    QgsRasterLayer\n)\nimport processing\n\n# Red, Green, Blue layer names\nred_band_layer_name = \"L3A_202312260087_20230808_37612078_R\"\ngreen_band_layer_name = \"L3A_202312260087_20230808_37612078_G\"\nblue_band_layer_name = \"L3A_202312260087_20230808_37612078_B\"\n\n# Retrieve layers from the active QGIS project\nproject = QgsProject.instance()\n\nred_band_layer = project.mapLayersByName(red_band_layer_name)[0]\ngreen_band_layer = project.mapLayersByName(green_band_layer_name)[0]\nblue_band_layer = project.mapLayersByName(blue_band_layer_name)[0]\n\n# Get file paths for the respective layers\nred_band_path = red_band_layer.dataProvider().dataSourceUri()\ngreen_band_path = green_band_layer.dataProvider().dataSourceUri()\nblue_band_path = blue_band_layer.dataProvider().dataSourceUri()\n\n# Generate file path for output (stored in memory)\noutput_virtual_raster = 'memory:R_G_B_Composite'\n\n# Merge the layers into a color composite (R, G, B)\nprocessing.run(\n    \"gdal:buildvirtualraster\",\n    {\n        'INPUT': [red_band_path, green_band_path, blue_band_path],\n        'RESOLUTION': 0,  # Default to highest resolution of inputs\n        'SEPARATE': True,  # Treat each input as a separate band\n        'OUTPUT': output_virtual_raster\n    }\n)\n\n# Load the created composite layer into the QGIS project\noutput_layer = QgsRasterLayer(output_virtual_raster, \"RGB Composite\")\nif output_layer.isValid():\n    project.addMapLayer(output_layer)\nelse:\n    print(\"Failed to create the RGB Composite layer.\")"
  },
  {
    "request": "지금 나한테는 네개의 tif 파일 레이어가 있어.\n\n각각 모두 프로젝트에 올라와있어. \n\n이름은 다음과 같아:\nL3A_202312260087_20230808_37612078_R\nL3A_202312260087_20230808_37612078_G\nL3A_202312260087_20230808_37612078_B\nL3A_202312260087_20230808_37612078_N\n\n각각의 영상은 위성으로 촬영한 원본 tif 파일인데, \nL3A_202312260087_20230808_37612078_R는 Red 밴드,\nL3A_202312260087_20230808_37612078_G는 Green 밴드,\nL3A_202312260087_20230808_37612078_B는 Blue 밴드\nL3A_202312260087_20230808_37612078_N은 NIR 밴드를 의미해.\n\n내가 원하고싶은건 NDVI 를 실제 지도로 보고싶어. \n\nqgis.analysis.QgsRasterCalculator 를 사용해줘. \n\n그리고 코드를 작성할 때는 항상 견고하지만, 가장 간단하게 목표를 이룰 수 있도록 작성할 수 있도록 해줘.\n\n간단하게라는 말은 짧게가 아니라, 이해하기 쉽게라는 뜻이야.\n\n인터넷 검색을 통해 이럴 경우 어떤 코드를 사용하는지 하며 double check 를 해줘.\n특히, QGIS 공식 Documentation 을 참고해서 내가 사용하고 있는 가장 최신 버젼의 3.36.3 에 해당하는 코드인지를 확실하게 해줘.",
    "response": "from qgis.analysis import QgsRasterCalculator, QgsRasterCalculatorEntry\nfrom qgis.core import QgsProject, QgsRasterLayer\n\n# 사용할 레이어 이름 정의\nred_band_name = \"L3A_202312260087_20230808_37612078_R\"\nnir_band_name = \"L3A_202312260087_20230808_37612078_N\"\n\n# Red 밴드 레이어 가져오기\nred_layer = QgsProject.instance().mapLayersByName(red_band_name)[0]\n# NIR 밴드 레이어 가져오기\nnir_layer = QgsProject.instance().mapLayersByName(nir_band_name)[0]\n\n# NDVI 계산 공식: (NIR - Red) / (NIR + Red)\n# QgsRasterCalculatorEntry를 통해 밴드 입력 정의\nentries = []\n\nnir_entry = QgsRasterCalculatorEntry()\nnir_entry.ref = 'NIR@1'  # 밴드 1 사용\nnir_entry.raster = nir_layer\nnir_entry.bandNumber = 1\nentries.append(nir_entry)\n\nred_entry = QgsRasterCalculatorEntry()\nred_entry.ref = 'RED@1'  # 밴드 1 사용\nred_entry.raster = red_layer\nred_entry.bandNumber = 1\nentries.append(red_entry)\n\n# 출력 NDVI 레이어 위치 (메모리 내 저장)\noutput_file = '/vsimem/ndvi.tif'\n\n# NDVI 계산\nndvi_calc = QgsRasterCalculator(\n    \"(NIR@1 - RED@1) / (NIR@1 + RED@1)\",  # NDVI 공식\n    output_file,  # 결과 파일 위치\n    \"GTiff\",  # 출력 포맷\n    nir_layer.extent(),  # 계산 범위 (NIR 레이어의 Extent 사용)\n    nir_layer.width(),  # 계산 해상도\n    nir_layer.height(),  # 계산 해상도\n    entries  # 입력된 밴드 정보\n)\n\n# 계산 실행\nndvi_calc.processCalculation()\n\n# 결과 파일을 QGIS 프로젝트에 추가\nndvi_layer = QgsRasterLayer(output_file, \"NDVI\")\nQgsProject.instance().addMapLayer(ndvi_layer)"
  },
  {
    "request": "지금 나한테는 4개의 tif 파일 레이어가 있어.\n\n각각 모두 프로젝트에 올라와있어. \n\n이름은 다음과 같아:\nL3A_202312260087_20230808_37612078_R\nL3A_202312260087_20230808_37612078_G\nL3A_202312260087_20230808_37612078_B\nL3A_202312260087_20230808_37612078_N\n\n각각의 영상은 위성으로 촬영한 원본 tif 파일인데\nL3A_202312260087_20230808_37612078_R는 Red 밴드,\nL3A_202312260087_20230808_37612078_G는 Green 밴드,\nL3A_202312260087_20230808_37612078_B는 Blue 밴드,\nL3A_202312260087_20230808_37612078_N는 NIR 밴드,\n\n를 의미해.\n\n각 입력파일을 개별 밴드로 배치할거야.\n\n\n레스터 병합 기능을 사용하고, 식생 활성도를 확인할 수 있는 false color 영상을 하나 만들어줘..\nR G B 밴드에 각각 어떤 파일이 들어가야할지 를 모르겠어. 이건 너가 알아서 잘 정해서 알려줘.\n\n그리고 합성한 결과는 레이어에 추가해서 바로 볼 수 있게 해줘. \n\ngdal:buildvirtualraster 기능을 사용해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom qgis.core import QgsProject\nimport processing\n\n# 레이어 이름 지정\nred_band = 'L3A_202312260087_20230808_37612078_N'  # NIR 밴드를 Red에 배치\ngreen_band = 'L3A_202312260087_20230808_37612078_R'  # Red 밴드를 Green에 배치\nblue_band = 'L3A_202312260087_20230808_37612078_G'  # Green 밴드를 Blue에 배치\n\n# 레이어 객체 가져오기\nred_layer = QgsProject.instance().mapLayersByName(red_band)[0]\ngreen_layer = QgsProject.instance().mapLayersByName(green_band)[0]\nblue_layer = QgsProject.instance().mapLayersByName(blue_band)[0]\n\n# vrt 파일 생성\nvrt_params = {\n    'INPUT': [red_layer.source(), green_layer.source(), blue_layer.source()],\n    'RESOLUTION': 0,  # 평균 해상도\n    'SEPARATE': True,\n    'PROJ_DIFFERENCE': False,\n    'ADD_ALPHA': False,\n    'ASSIGN_CRS': None,\n    'OUTPUT': 'TEMPORARY_OUTPUT'\n}\n\nvrt_output = processing.run(\"gdal:buildvirtualraster\", vrt_params)['OUTPUT']\n\n# 결과 레이어 추가\nresult_layer = QgsRasterLayer(vrt_output, \"False Color Composite\", \"gdal\")\nQgsProject.instance().addMapLayer(result_layer)"
  },
  {
    "request": "지금 이 레이어는 여러개의 featrue 가 저장되어있어. 각각의 폴리곤을 각각 shp 파일로 저장해줘.",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom qgis.core import QgsProject, QgsVectorLayer, QgsFeatureRequest, QgsVectorFileWriter, QgsWkbTypes\nimport processing\n\n# Get the active layer\nlayer = iface.activeLayer()\n\n# Check if the layer is a polygon layer\nif layer.geometryType() == QgsWkbTypes.PolygonGeometry:\n    \n    # Iterate over each feature in the active layer\n    for feature in layer.getFeatures():\n        \n        # Create a new memory layer for each feature\n        memory_layer = QgsVectorLayer(\"Polygon?crs={}\".format(layer.crs().authid()), \n                                      \"Feature_{}\".format(feature.id()), \n                                      \"memory\")\n        \n        # Start editing the memory layer\n        memory_layer.startEditing()\n        \n        # Add fields from the original layer\n        memory_layer.dataProvider().addAttributes(layer.fields())\n        memory_layer.updateFields()\n        \n        # Add the current feature to the new memory layer\n        memory_layer.dataProvider().addFeature(feature)\n        \n        # Stop editing and commit changes\n        memory_layer.commitChanges()\n        \n        # Add the new layer to the current project\n        QgsProject.instance().addMapLayer(memory_layer)\n\nelse:\n    print(\"The active layer is not a polygon layer.\")"
  },
  {
    "request": "이 레이어에서 CTP_ENG_NM 칼럼이 Incheon인 폴리곤을 새로운 레이어로 추출해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom qgis.core import QgsProject\nfrom qgis.core import QgsVectorLayer\n\n# Get the active layer\nlayer = iface.activeLayer()\n\n# Ensure the layer is valid\nif layer is not None and layer.isValid():\n\n    # Define the filter expression\n    expression = '\"CTP_ENG_NM\" = \\'Incheon\\''\n\n    # Use QgsFeatureRequest to filter features\n    request = QgsFeatureRequest()\n    request.setFilterExpression(expression)\n\n    # Create a memory layer for the output\n    output_layer = QgsVectorLayer('Polygon?crs=' + layer.crs().toWkt(), 'Filtered_Incheon', 'memory')\n    output_provider = output_layer.dataProvider()\n\n    # Add fields from the original layer to the new layer\n    output_provider.addAttributes(layer.fields())\n    output_layer.updateFields()\n\n    # Use a feature iterator with the filter\n    features = layer.getFeatures(request)\n    for feature in features:\n        output_provider.addFeature(feature)\n\n    # Add the new layer to the project\n    QgsProject.instance().addMapLayer(output_layer)"
  },
  {
    "request": "A라는 이름의 레이어와 B라는 이름의 레이어 두 개는 모두 폴리곤 feature야. 이 두 레이어를 병합해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nimport processing\nfrom qgis.core import QgsProject\n\n# Get the layers by their name\nlayer_a = QgsProject.instance().mapLayersByName('A')[0]\nlayer_b = QgsProject.instance().mapLayersByName('B')[0]\n\n# Merge the layers\nmerged_layer_output = processing.run(\"native:mergevectorlayers\", {\n    'LAYERS': [layer_a, layer_b],\n    'CRS': layer_a.crs(),\n    'OUTPUT': 'memory:'  # Save the output to memory\n})['OUTPUT']\n\n# Add the merged layer to the project\nQgsProject.instance().addMapLayer(merged_layer_output)"
  },
  {
    "request": "이 레이어의 좌표계를 EPSG:5174 로 지정하고 싶어! 지정해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom qgis.core import QgsProject, QgsCoordinateReferenceSystem\nfrom qgis.utils import iface\n\n# Get the active layer\nlayer = iface.activeLayer()\n\n# Check if the layer is valid\nif not layer:\n    print(\"No active layer selected.\")\nelse:\n    # Set the CRS to EPSG:5174\n    crs = QgsCoordinateReferenceSystem(\"EPSG:5174\")\n    layer.setCrs(crs)\n\n    # Refresh the layer to apply changes\n    layer.triggerRepaint()\n\n    # Add the layer to the project if not already added\n    if not QgsProject.instance().mapLayersByName(layer.name()):\n        QgsProject.instance().addMapLayer(layer)"
  },
  {
    "request": "Incheon 레이어를 NamGu 레이어로 clip 해줄래??",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom qgis.core import QgsProject, QgsVectorLayer\nimport processing\n\n# Fetch the map layers by name\nincheon_layer = QgsProject.instance().mapLayersByName(\"Incheon\")[0]\nnamgu_layer = QgsProject.instance().mapLayersByName(\"NamGu\")[0]\n\n# Run the clip process\nclip_result = processing.run(\"native:clip\", {\n    'INPUT': incheon_layer,\n    'OVERLAY': namgu_layer,\n    'OUTPUT': 'memory:'  # Save the results in memory\n})\n\n# Add the clipped layer to the project\nclipped_layer = clip_result['OUTPUT']\nQgsProject.instance().addMapLayer(clipped_layer)"
  },
  {
    "request": "ctprvn 레이어에는 여러개의 폴리곤 feature 가 있어. 각 폴리곤 내부 중심에 포인트 feature를 생성하여 새로운 레이어를 만들어줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nlayer = iface.activeLayer()\n\nif not layer:\n    print(\"No active layer found.\")\nelse:\n    centroids = [feature.geometry().centroid() for feature in layer.getFeatures()]\n\n    point_fields = QgsFields()\n    for field in layer.fields():\n        point_fields.append(field)\n\n    point_layer = QgsVectorLayer(\"Point?crs=EPSG:4326\", \"Centroids\", \"memory\")\n    point_layer_data = point_layer.dataProvider()\n\n    point_layer_data.addAttributes(point_fields)\n    point_layer.updateFields()\n\n    point_features = []\n    for feature in layer.getFeatures():\n        point_feature = QgsFeature()\n        point_feature.setGeometry(feature.geometry().centroid())\n        point_feature.setAttributes(feature.attributes())\n        point_features.append(point_feature)\n\n    point_layer_data.addFeatures(point_features)\n    QgsProject.instance().addMapLayer(point_layer)"
  },
  {
    "request": "ctprvn 레이어의 이름을 abcd 로 변환해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nlayer = None\nproject = QgsProject.instance()\nfor lyr in project.mapLayers().values():\n    if lyr.name() == 'ctprvn':\n        layer = lyr\n        break\n\nif layer:\n    layer.setName('abcd')\n    project.addMapLayer(layer)"
  },
  {
    "request": "pp 레이어에 있는 각 포인트들에 거리 1000씩 버퍼를 적용해서 새로운 레이어를 만들어줘.",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nimport processing\n\nlayer = QgsProject.instance().mapLayersByName('pp')[0]\n\nbuffer_output = processing.run(\"native:buffer\", {\n    'INPUT': layer,\n    'DISTANCE': 1000,\n    'SEGMENTS': 5,\n    'END_CAP_STYLE': 0,\n    'JOIN_STYLE': 0,\n    'MITER_LIMIT': 2,\n    'DISSOLVE': False,\n    'OUTPUT': 'memory:'\n})\n\nbuffer_layer = buffer_output['OUTPUT']\nQgsProject.instance().addMapLayer(buffer_layer)"
  },
  {
    "request": "pp 레이어에 있는 포인트 feature들을 모두 연결하는 line 레이어를 생성해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\n# Get the active point layer from the user\npoint_layer = iface.activeLayer()\n\n# Connect all features with a line\nline_features = []\nfeature_points = []\n\nfor feature in point_layer.getFeatures():\n    geom = feature.geometry()\n    if geom.isMultipart():\n        # Handle multipart geometries\n        for part in geom.asMultiPoint():\n            feature_points.append(part)\n    else:\n        feature_points.append(geom.asPoint())\n\nif feature_points:\n    polyline = QgsGeometry.fromPolylineXY(feature_points)\n    line_feature = QgsFeature()\n    line_feature.setGeometry(polyline)\n    line_features.append(line_feature)\n\n# Create a temporary line layer in memory\nline_layer = QgsVectorLayer(\"LineString?crs=\" + point_layer.crs().authid(), \"Connected Lines\", \"memory\")\nline_layer_data_provider = line_layer.dataProvider()\nline_layer_data_provider.addFeatures(line_features)\n\nQgsProject.instance().addMapLayer(line_layer)"
  },
  {
    "request": "ab 레이어에 있는 폴리곤 feature를 line feature로 변환해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nlayer = iface.activeLayer()\nif layer is None:\n    quit()\n\nimport processing\nfrom qgis.core import QgsProject\n\nparams = {\n    'INPUT': layer,\n    'OUTPUT': 'memory:'\n}\n\nline_layer = processing.run('native:polygonstolines', params)['OUTPUT']\n\nQgsProject.instance().addMapLayer(line_layer)"
  },
  {
    "request": "Incheon 레이어의 모든 폴리곤을 하나로 병합하여 새로운 레이어를 만들어줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nfrom qgis.core import QgsVectorLayer, QgsProject\nimport processing\n\n# 현재 활성 레이어 가져오기\nlayer = iface.activeLayer()\n\n# 'Incheon' 레이어가 맞는지 확인\nif layer.name() == \"Incheon\":\n    # 모든 폴리곤을 하나로 병합\n    dissolved_layer = processing.run(\"native:dissolve\", {\n        'INPUT': layer,\n        'OUTPUT': 'memory:'\n    })['OUTPUT']\n\n    # 새 레이어를 프로젝트에 추가\n    QgsProject.instance().addMapLayer(dissolved_layer)"
  },
  {
    "request": "output 레이어에서 NamGu 레이어의 영역 만큼 잘라서 새로운 레이어로 만들어줄래?:",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import QVariant\nimport processing\n\nactive_layer = iface.activeLayer()\nnamgu_layer = None\nfor layer in QgsProject.instance().mapLayers().values():\n    if \"NamGu\" in layer.name():\n        namgu_layer = layer\n        break\n\nif active_layer is None or namgu_layer is None:\n    raise ValueError(\"Required layers are not found.\")\n\nparams = {\n    'INPUT': active_layer,\n    'OVERLAY': namgu_layer,\n    'OUTPUT': 'memory:'\n}\n\noutput = processing.run(\"native:clip\", params)['OUTPUT']\nQgsProject.instance().addMapLayer(output)"
  },
  {
    "request": "Incheon 레이어의 각 폴리곤 feature를 Count 속성값 50을 기준으로 분류하여 색을 다르게 지정해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\n\nlayer = iface.activeLayer() if iface.activeLayer().name() == 'Incheon' else None\n\nif layer:\n    categories = []\n    for unique_value in layer.uniqueValues(layer.fields().indexOf('Count')):\n        if unique_value <= 50:\n            symbol = QgsSymbol.defaultSymbol(layer.geometryType())\n            symbol.setColor(QColor(255, 0, 0))  # Red for Count <= 50\n        else:\n            symbol = QgsSymbol.defaultSymbol(layer.geometryType())\n            symbol.setColor(QColor(0, 255, 0))  # Green for Count > 50\n        category = QgsRendererCategory(unique_value, symbol, str(unique_value))\n        categories.append(category)\n\n    renderer = QgsCategorizedSymbolRenderer('Count', categories)\n    layer.setRenderer(renderer)\n    layer.triggerRepaint()\n    iface.layerTreeView().refreshLayerSymbology(layer.id())"
  },
  {
    "request": "Incheon 레이어에 있는 각 폴리곤 feature 내에 Factory 레이어의 포인트 feature가 각각 몇개가 있는지 count 해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nincheon_layer = None\nfactory_layer = None\n\nfor layer in QgsProject.instance().mapLayers().values():\n    if 'Incheon' in layer.name():\n        incheon_layer = layer\n    elif 'Factory' in layer.name():\n        factory_layer = layer\n\nif not incheon_layer or not factory_layer:\n    raise Exception(\"Either 'Incheon' or 'Factory' layer is not found.\")\n\nprocessing.run(\"native:countpointsinpolygon\", {\n    'POLYGONS': incheon_layer, \n    'POINTS': factory_layer, \n    'CLASSFIELD': '', \n    'COUNTFIELD': 'factory_count', \n    'OUTPUT': 'memory:'\n})\n\nalg_result = processing.run(\"native:countpointsinpolygon\", {\n    'POLYGONS': incheon_layer,\n    'POINTS': factory_layer,\n    'CLASSFIELD': '',\n    'COUNTFIELD': 'factory_count',\n    'OUTPUT': 'memory:'\n})\n\ncount_layer = alg_result['OUTPUT']\nQgsProject.instance().addMapLayer(count_layer)"
  },
  {
    "request": "Road 레이어에서 AREA 속성값이 1000 이하인 폴리곤만 새로 추출해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nlayer = iface.activeLayer()\n\nif not layer:\n    print(\"활성 레이어가 없습니다.\")\nelse:    \n    query = '\"AREA\" <= 1000'\n    \n    selected_layer = processing.run(\"native:extractbyexpression\", {\n        'INPUT': layer,\n        'EXPRESSION': query,\n        'OUTPUT': 'memory:'\n    })['OUTPUT']\n    \n    QgsProject.instance().addMapLayer(selected_layer)"
  },
  {
    "request": "NamGu 레이어와교차되는 Factory 레이어의 포인트들을 추출해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nnamgu_layer = None\nfactory_layer = None\n\nfor layer in QgsProject.instance().mapLayers().values():\n    if 'NamGu' in layer.name():\n        namgu_layer = layer\n    elif 'Factory' in layer.name():\n        factory_layer = layer\n\nif namgu_layer and factory_layer:\n    params = {\n        'INPUT': factory_layer,\n        'PREDICATE': [0],  # Intersects\n        'INTERSECT': namgu_layer,\n        'OUTPUT': 'memory:IntersectedPoints'\n    }\n    result = processing.run(\"native:extractbylocation\", params)\n    intersected_points_layer = result['OUTPUT']\n    QgsProject.instance().addMapLayer(intersected_points_layer)"
  },
  {
    "request": "Road 레이어의 폴리곤 feature를 라인 feature로 바꿔줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nlayer = iface.activeLayer()\n\nif layer is None:\n    raise Exception(\"No active layer found\")\n\nif layer.name() == 'Road':\n    line_layer = QgsVectorLayer(\"LineString?crs=\" + layer.crs().authid(), \"Road_Lines\", \"memory\")\n    \n    line_fields = line_layer.dataProvider().fields()\n    line_layer.dataProvider().addAttributes(line_fields)\n    line_layer.updateFields()\n\n    features = layer.getFeatures()\n\n    for feature in features:\n        geom = feature.geometry()\n        if geom.isMultipart():\n            multiline = geom.asMultiPolygon()\n            for part in multiline:\n                for polyline in part:\n                    line_feature = QgsFeature(line_fields)\n                    line_feature.setGeometry(QgsGeometry.fromPolylineXY(polyline))\n                    line_feature.setAttributes(feature.attributes())\n                    line_layer.dataProvider().addFeatures([line_feature])\n        else:\n            polygon = geom.asPolygon()\n            for polyline in polygon:\n                line_feature = QgsFeature(line_fields)\n                line_feature.setGeometry(QgsGeometry.fromPolylineXY(polyline))\n                line_feature.setAttributes(feature.attributes())\n                line_layer.dataProvider().addFeatures([line_feature])\n\n    QgsProject.instance().addMapLayer(line_layer)\nelse:\n    raise Exception(\"The active layer is not named 'Road'\")"
  },
  {
    "request": "토지피복_4326, 토양도_4326, dem_4326 레이어로 동일한 가중치를 적용해서 래스터 계산을 해줘\nprocessing.run() 함수의 native:rastercalc 기능을 사용해줘\n\n\nfrom qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\n\nproject = QgsProject.instance()\n\nland_cover_layer_name = \"토지피복_래스터\"\nsoil_map_layer_name = \"토양도_래스터\"\ndem_layer_name = \"dem_래스터\"\n\nland_cover_layer = project.mapLayersByName(land_cover_layer_name)[0]\nsoil_map_layer = project.mapLayersByName(soil_map_layer_name)[0]\ndem_layer = project.mapLayersByName(dem_layer_name)[0]\n\nland_cover_path = land_cover_layer.dataProvider().dataSourceUri()\nsoil_map_path = soil_map_layer.dataProvider().dataSourceUri()\ndem_path = dem_layer.dataProvider().dataSourceUri()\n\noutput_raster_calc = 'memory:raster_calc_result'\n\nprocessing.run(\"native:rastercalc\", {\n    'EXPRESSION': '(\"1@1\" + \"2@1\" + \"3@1\") / 3',\n    'LAYERS': [land_cover_path, soil_map_path, dem_path],\n    'CRS': land_cover_layer.crs(),\n    'OUTPUT': output_raster_calc\n})\n\nresult_layer = QgsRasterLayer(output_raster_calc, \"Raster Calculation Result\")\nif result_layer.isValid():\n    project.addMapLayer(result_layer)\n\n이 코드를 대체적으로 많이 활용하되, 저장하는 위치는 메모리가 아니라 temp 임시 경로를 사용할 수 있도록 해줘.",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport tempfile\n\nproject = QgsProject.instance()\n\n# 레이어 이름 설정\nland_cover_layer_name = \"토지피복_4326\"\nsoil_map_layer_name = \"토양도_4326\"\ndem_layer_name = \"dem_4326\"\n\n# 레이어 불러오기\nland_cover_layer = project.mapLayersByName(land_cover_layer_name)[0]\nsoil_map_layer = project.mapLayersByName(soil_map_layer_name)[0]\ndem_layer = project.mapLayersByName(dem_layer_name)[0]\n\n# 출력 파일 경로 설정\ntemp_dir = tempfile.gettempdir()\noutput_raster_calc = f\"{temp_dir}/raster_calc_result.tif\"\n\n# Raster Calculator 실행\nexpression = f'(\"{land_cover_layer.name()}@1\" + \"{soil_map_layer.name()}@1\" + \"{dem_layer.name()}@1\") / 3'\n\nprocessing.run(\"native:rastercalc\", {\n    'EXPRESSION': expression,\n    'LAYERS': [land_cover_layer, soil_map_layer, dem_layer],\n    'CRS': land_cover_layer.crs().authid(),\n    'EXTENT': land_cover_layer.extent(),\n    'OUTPUT': output_raster_calc\n})\n\n# 결과 레이어 추가\nresult_layer = QgsRasterLayer(output_raster_calc, \"Raster Calculation Result\")\nif result_layer.isValid():\n    project.addMapLayer(result_layer)\nelse:\n    print(\"결과 레이어가 유효하지 않습니다.\")"
  },
  {
    "request": "dem_4326 레이어를 200 이하인 픽셀은 3으로, 200 초과 400 이하인 픽셀은 2로, 400 초과인 픽셀은 1로 reclassify 해줄래?",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport tempfile\n\n# 프로젝트 및 레이어 설정\nlayer_name = \"dem_4326\"\nproject = QgsProject.instance()\nlayer = project.mapLayersByName(layer_name)[0]\n\n# 출력 파일 경로 설정\noutput_reclassified = tempfile.gettempdir() + \"/reclassified_dem.tif\"\n\n# 레스터 재분류 실행\nprocessing.run(\"native:reclassifybytable\", {\n    'INPUT_RASTER': layer,  # 레이어 객체 직접 전달\n    'RASTER_BAND': 1,\n    'TABLE': [\n        0, 200, 3,\n        200, 400, 2,\n        400, 99999, 1\n    ],\n    'NODATA': -9999,\n    'RANGE_BOUNDARIES': 0,  # 상한값 제외\n    'TARGET_NODATA': -9999,\n    'DATA_TYPE': 5,  # Byte\n    'OUTPUT': output_reclassified\n})\n\n# 결과 레이어 추가\nreclassified_layer = QgsRasterLayer(output_reclassified, \"Reclassified DEM\")\nif reclassified_layer.isValid():\n    project.addMapLayer(reclassified_layer)\nelse:\n    print(\"Reclassified 레이어가 유효하지 않습니다.\")"
  },
  {
    "request": "토양도_4326 레이어를 300~400번대의 값을 3, 200번대의 값을 2, 600번대의 값을 1, 그 외의 수는 0으로 reclassify 해줄래?\n\n결과값은 메모리에 저장하지 말고, temp 경로를 활용해서 저장해줘.\n\nprocessing.run(\"native:reclassifybytable\", {'INPUT_RASTER':'C:/Users/Public/Documents/ESTsoft/CreatorTemp/raster_calc_result.tif','RASTER_BAND':1,'TABLE':['','',''],'NO_DATA':-9999,'RANGE_BOUNDARIES':0,'NODATA_FOR_MISSING':False,'DATA_TYPE':5,'OUTPUT':'TEMPORARY_OUTPUT'})\n위 코드를 참고해서 알려줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\nimport tempfile\nfrom qgis.core import QgsProject, QgsRasterLayer\n\nproject = QgsProject.instance()\nlayer_name = \"토양도_4326\"\nlayer = project.mapLayersByName(layer_name)[0]\n\nlayer_path = layer.source()\n\ntemp_dir = tempfile.gettempdir()\nreclassified_output = f\"{temp_dir}/reclassified_raster.tif\"\n\nprocessing.run(\"native:reclassifybytable\", {\n    'INPUT_RASTER': layer_path,\n    'RASTER_BAND': 1,\n    'TABLE': [200, 299, 2, 300, 499, 3, 600, 699, 1],\n    'NO_DATA': -9999,\n    'RANGE_BOUNDARIES': 0,\n    'NODATA_FOR_MISSING': False,\n    'DATA_TYPE': 5,\n    'OUTPUT': reclassified_output\n})\n\noutput_layer = QgsRasterLayer(reclassified_output, \"Reclassified Raster\")\nif output_layer.isValid():\n    project.addMapLayer(output_layer)"
  },
  {
    "request": "토양도_4326 레이어를\n5, 6의 값을 1로, 3,4는 2으로, 1,2는 3으로, \n그 외의 수는 0으로 reclassify 해줄래?\n\n결과값은 메모리에 저장하지 말고, temp 경로를 활용해서 저장해줘.\n\nprocessing.run(\"native:reclassifybytable\", {'INPUT_RASTER':'C:/Users/Public/Documents/ESTsoft/CreatorTemp/raster_calc_result.tif','RASTER_BAND':1,'TABLE':['','',''],'NO_DATA':-9999,'RANGE_BOUNDARIES':0,'NODATA_FOR_MISSING':False,'DATA_TYPE':5,'OUTPUT':'TEMPORARY_OUTPUT'})\n위 코드를 참고해서 알려줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\nimport tempfile\n\nproject = QgsProject.instance()\n\nlayer_name = \"토양도_4326\"\ninput_layer = project.mapLayersByName(layer_name)[0]\n\ninput_layer_path = input_layer.source()\n\ntemp_dir = tempfile.gettempdir()\nreclassified_output = f\"{temp_dir}/reclassified_raster.tif\"\n\nprocessing.run(\"native:reclassifybytable\", {\n    'INPUT_RASTER': input_layer_path,\n    'RASTER_BAND': 1,\n    'TABLE': [\n        1, 2, 3,\n        3, 4, 2,\n        5, 6, 1\n    ],\n    'NO_DATA': -9999,\n    'RANGE_BOUNDARIES': 0,\n    'NODATA_FOR_MISSING': False,\n    'DATA_TYPE': 5,\n    'OUTPUT': reclassified_output\n})\n\nreclassified_layer = QgsRasterLayer(reclassified_output, \"Reclassified Raster\")\nif reclassified_layer.isValid():\n    project.addMapLayer(reclassified_layer)"
  },
  {
    "request": "Re_토지피복, Re_토양도, Re_DEM 레이어로 래스터 계산을 할거야.\n\nRe_토지피복은 가중치를 0.3, Re_토양도는 가중치를 0.5, Re_DEM는 가중치를 0.2로 지정해줘.\n\n\nprocessing.run(\"native:rastercalc\", {'LAYERS':['D:/원격탐사팀/LLM/Re_DEM.tif','D:/원격탐사팀/LLM/Re_토지피복.tif','D:/원격탐사팀/LLM/Re_토양도.tif'],'EXPRESSION':'0.2*\"Re_토지피복@1\" + 0.5*\"Re_DEM@1\" + 0.3*\"Re_토양도@1\"\\n','EXTENT':None,'CELL_SIZE':None,'CRS':None,'OUTPUT':'TEMPORARY_OUTPUT'})\n위 코드를 참고해서 작성해줘.\n\n결과값은 메모리에 저장하지 말고, temp 경로를 활용해서 저장해줘.",
    "response": "from qgis.core import *\nimport processing\nimport tempfile\n\n# QGIS 프로젝트 설정\nproject = QgsProject.instance()\n\n# 레이어 로드\nlandcover_layer = project.mapLayersByName(\"Re_토지피복\")[0]\nsoil_layer = project.mapLayersByName(\"Re_토양도\")[0]\ndem_layer = project.mapLayersByName(\"Re_DEM\")[0]\n\n# 출력 경로 설정\ntemp_dir = tempfile.gettempdir()\noutput_path = f\"{temp_dir}/raster_calc_output.tif\"\n\n# 래스터 계산 실행\nprocessing.run(\"native:rastercalc\", {\n    'LAYERS': [landcover_layer, soil_layer, dem_layer],  # 레이어 객체 전달\n    'EXPRESSION': '(\"Re_토지피복@1\" * 0.3) + (\"Re_토양도@1\" * 0.5) + (\"Re_DEM@1\" * 0.2)',  # 밴드 번호 정확히 지정\n    'OUTPUT': output_path\n})\n\n# 출력 레이어 추가\noutput_layer = QgsRasterLayer(output_path, \"Raster Calculation Result\")\nif output_layer.isValid():\n    project.addMapLayer(output_layer)\nelse:\n    print(\"Failed to create the raster calculation result layer.\")"
  },
  {
    "request": "토지피복도 레이어를 EPSG:4326 좌표계로 투영 시켜줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\n\nproject = QgsProject.instance()\n\nlandcover_layer = iface.activeLayer()\n\ntransformation_parameters = {\n    'INPUT': landcover_layer,\n    'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:4326'),\n    'OUTPUT': 'memory:transformed_landcover'\n}\n\nresult = processing.run(\"native:reprojectlayer\", transformation_parameters)\n\ntransformed_layer = result['OUTPUT']\n\nif transformed_layer.isValid():\n    project.addMapLayer(transformed_layer)"
  },
  {
    "request": "이 레이어를 래스터화 해줘\n\nprocessing.run(\"gdal:rasterize\", {'INPUT':'D:\\\\원격탐사팀\\\\LLM\\\\Lab#8\\\\토양도2.shp','FIELD':'CODE_DC','BURN':0,'USE_Z':False,'UNITS':1,'WIDTH':5,'HEIGHT':5,'EXTENT':None,'NODATA':0,'OPTIONS':'','DATA_TYPE':5,'INIT':None,'INVERT':False,'EXTRA':'','OUTPUT':'TEMPORARY_OUTPUT'})\n\n위 코드를 참고해서 잘 작성해줘!!!\n\n결과값은 메모리에 저장하지 말고, temp 경로를 활용해서 저장해줘.",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\nimport tempfile\n\nactive_layer = iface.activeLayer()\noutput_path = f\"{tempfile.gettempdir()}/rasterized_output.tif\"\n\nprocessing.run(\"gdal:rasterize\", {\n    'INPUT': active_layer,\n    'FIELD': 'CODE_DC',\n    'BURN': 0,\n    'USE_Z': False,\n    'UNITS': 1,\n    'WIDTH': 5,\n    'HEIGHT': 5,\n    'EXTENT': None,\n    'NODATA': 0,\n    'OPTIONS': '',\n    'DATA_TYPE': 5,\n    'INIT': None,\n    'INVERT': False,\n    'EXTRA': '',\n    'OUTPUT': output_path\n})\n\nraster_layer = QgsRasterLayer(output_path, \"Rasterized Layer\")\nif raster_layer.isValid():\n    QgsProject.instance().addMapLayer(raster_layer)"
  },
  {
    "request": "토지피복도 레이어를 EPSG:4326 좌표계로 투영 시켜줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\n\nproject = QgsProject.instance()\n\nlandcover_layer = iface.activeLayer()\n\ntransformation_parameters = {\n    'INPUT': landcover_layer,\n    'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:4326'),\n    'OUTPUT': 'memory:transformed_landcover'\n}\n\nresult = processing.run(\"native:reprojectlayer\", transformation_parameters)\n\ntransformed_layer = result['OUTPUT']\n\nif transformed_layer.isValid():\n    project.addMapLayer(transformed_layer)"
  },
  {
    "request": "토양도 레이어는 벡터 레이어인데, 이 레이어를 래스터로 변환하고 싶어.\n\nprocessing.run(\"gdal:rasterize\", {'INPUT':'D:/원격탐사팀/LLM/시연 데이터/토양도/Soil_map.shp','FIELD':'CODE_DC_1','BURN':0,'USE_Z':False,'UNITS':1,'WIDTH':5,'HEIGHT':5,'EXTENT':None,'NODATA':0,'OPTIONS':'','DATA_TYPE':5,'INIT':None,'INVERT':False,'EXTRA':'','OUTPUT':'TEMPORARY_OUTPUT'})\n\n이 코드를 참고해서 작성해줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\nimport tempfile\n\nlayer = iface.activeLayer()\nfield_name = 'CODE_DC_1'\npixel_size = 5\n\ntemp_dir = tempfile.gettempdir()\nrasterized_output = f\"{temp_dir}/rasterized_soil_map.tif\"\n\nprocessing.run(\"gdal:rasterize\", {\n    'INPUT': layer.source(),\n    'FIELD': field_name,\n    'BURN': 0,\n    'USE_Z': False,\n    'UNITS': 1,\n    'WIDTH': pixel_size,\n    'HEIGHT': pixel_size,\n    'EXTENT': layer.extent(),\n    'NODATA': 0,\n    'OPTIONS': '',\n    'DATA_TYPE': 5,\n    'INIT': None,\n    'INVERT': False,\n    'EXTRA': '',\n    'OUTPUT': rasterized_output\n})\n\nraster_layer = QgsRasterLayer(rasterized_output, \"Rasterized Soil Map\")\nif raster_layer.isValid():\n    QgsProject.instance().addMapLayer(raster_layer)"
  },
  {
    "request": "이 래스터 레이어를 재분류(reclassify) 할거야.\n200 이하인 픽셀은 3으로, 200~400 이하인 픽셀은 2로, 400 초과인 픽셀은 1로 reclassify 해줄래?\n\nnative:reclassifybytable 기능을 써서 작성해줘\n결과값은 메모리에 저장하지 말고, temp 경로를 활용해서 저장해줘.",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\nimport tempfile\n\nproject = QgsProject.instance()\nraster_layer = iface.activeLayer()\nraster_layer_path = raster_layer.source()\n\ntemp_dir = tempfile.gettempdir()\nreclassified_output = f\"{temp_dir}/reclassified_raster.tif\"\n\nprocessing.run(\"native:reclassifybytable\", {\n    'INPUT_RASTER': raster_layer_path,\n    'RASTER_BAND': 1,\n    'TABLE': [\n        0, 200, 3,\n        200, 400, 2,\n        400, 999999, 1\n    ],\n    'NO_DATA': -1,\n    'RANGE_BOUNDARIES': 0,\n    'OUTPUT': reclassified_output\n})\n\nreclassified_layer = QgsRasterLayer(reclassified_output, \"Reclassified Raster\")\nif reclassified_layer.isValid():\n    project.addMapLayer(reclassified_layer)\nelse:\n    print(\"Failed to create the reclassified raster layer.\")"
  },
  {
    "request": "토지피복_4326 레이어를 300~499인 값을 3, 200번대의 값을 2, 600번대의 값을 1,\n0~199, 500~599, 7000 이상의 값은 -9999(nodata)로 reclassify 해줄래?\n\n결과값은 메모리에 저장하지 말고, temp 경로를 활용해서 저장해줘.\n\nprocessing.run(\"native:reclassifybytable\", {'INPUT_RASTER':'C:/Users/Public/Documents/ESTsoft/CreatorTemp/raster_calc_result.tif','RASTER_BAND':1,'TABLE':['','',''],'NO_DATA':-9999,'RANGE_BOUNDARIES':0,'NODATA_FOR_MISSING':False,'DATA_TYPE':5,'OUTPUT':'TEMPORARY_OUTPUT'})\n위 코드를 참고해서 알려줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\nimport tempfile\n\nlayer_name = \"토지피복_4326\"\nproject = QgsProject.instance()\ninput_layer = project.mapLayersByName(layer_name)[0]\ninput_raster_path = input_layer.dataProvider().dataSourceUri()\n\ntemp_dir = tempfile.gettempdir()\nreclassified_output = f\"{temp_dir}/reclassified_raster.tif\"\n\nprocessing.run(\"native:reclassifybytable\", {\n    'INPUT_RASTER': input_raster_path,\n    'RASTER_BAND': 1,\n    'TABLE': [\n        0, 199, -9999,\n        200, 299, 2,\n        300, 499, 3,\n        500, 599, -9999,\n        600, 699, 1,\n        700, 6999, -9999,\n        7000, 100000, -9999\n    ],\n    'NO_DATA': -9999,\n    'RANGE_BOUNDARIES': 0,\n    'NODATA_FOR_MISSING': False,\n    'DATA_TYPE': 5,\n    'OUTPUT': reclassified_output\n})\n\nreclassified_layer = QgsRasterLayer(reclassified_output, \"Reclassified Raster\")\nif reclassified_layer.isValid():\n    project.addMapLayer(reclassified_layer)\nelse:\n    print(\"Failed to create the reclassified raster layer.\")"
  },
  {
    "request": "토양도_4326 레이어를\n5~6의 값을 3로, 3~4는 2으로, 1~2는 1으로,\n그리고 7 이상의 수와 정수가 아닌 수는 -9999(nodata)로 reclassify 해줄래?\n\n결과값은 메모리에 저장하지 말고, temp 경로를 활용해서 저장해줘.\n\nprocessing.run(\"native:reclassifybytable\", {'INPUT_RASTER':'C:/Users/Public/Documents/ESTsoft/CreatorTemp/raster_calc_result.tif','RASTER_BAND':1,'TABLE':['','',''],'NO_DATA':-9999,'RANGE_BOUNDARIES':0,'NODATA_FOR_MISSING':False,'DATA_TYPE':5,'OUTPUT':'TEMPORARY_OUTPUT'})\n위 코드를 참고해서 알려줘",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\nimport tempfile\nfrom qgis.core import QgsProject\n\nproject = QgsProject.instance()\ninput_layer_name = \"토양도_4326\"\n\ninput_layer = project.mapLayersByName(input_layer_name)[0]\ninput_raster_path = input_layer.dataProvider().dataSourceUri()\n\ntemp_dir = tempfile.gettempdir()\nreclassified_output = f\"{temp_dir}/reclassified_raster.tif\"\n\nprocessing.run(\"native:reclassifybytable\", {\n    'INPUT_RASTER': input_raster_path,\n    'RASTER_BAND': 1,\n    'TABLE': [\n        1, 2, 1,\n        3, 4, 2,\n        5, 6, 3\n    ],\n    'NO_DATA': -9999,\n    'RANGE_BOUNDARIES': 0,\n    'NODATA_FOR_MISSING': True,\n    'DATA_TYPE': 5,\n    'OUTPUT': reclassified_output\n})\n\nreclassified_layer = QgsRasterLayer(reclassified_output, \"Reclassified Raster\")\nif reclassified_layer.isValid():\n    project.addMapLayer(reclassified_layer)"
  },
  {
    "request": "Re_토지피복, Re_토양도, Re_DEM 레이어로 래스터 계산을 할거야.\n\nRe_토지피복은 가중치를 0.3, Re_토양도는 가중치를 0.5, Re_DEM는 가중치를 0.2로 지정해줘.\n\nprocessing.run(\"native:rastercalc\", {'LAYERS':['D:/원격탐사팀/LLM/Re_DEM.tif','D:/원격탐사팀/LLM/Re_토지피복.tif','D:/원격탐사팀/LLM/Re_토양도.tif'],'EXPRESSION':'0.2*\"Re_토지피복@1\" + 0.5*\"Re_DEM@1\" + 0.3*\"Re_토양도@1\"\\n','EXTENT':None,'CELL_SIZE':None,'CRS':None,'OUTPUT':'TEMPORARY_OUTPUT'})\n위 코드를 참고해서 작성해줘.\n\n결과값은 메모리에 저장하지 말고, temp 경로를 활용해서 저장해줘.",
    "response": "from qgis.core import *\nfrom qgis.gui import *\nfrom qgis.analysis import *\nfrom qgis.processing import *\nfrom qgis.utils import *\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nimport processing\nimport processing\nimport tempfile\nfrom qgis.core import QgsProject, QgsRasterLayer\n\nproject = QgsProject.instance()\n\ndem_layer_name = \"Re_DEM\"\nland_cover_layer_name = \"Re_토지피복\"\nsoil_layer_name = \"Re_토양도\"\n\ndem_layer = project.mapLayersByName(dem_layer_name)[0]\nland_cover_layer = project.mapLayersByName(land_cover_layer_name)[0]\nsoil_layer = project.mapLayersByName(soil_layer_name)[0]\n\ndem_path = dem_layer.dataProvider().dataSourceUri()\nland_cover_path = land_cover_layer.dataProvider().dataSourceUri()\nsoil_path = soil_layer.dataProvider().dataSourceUri()\n\ntemp_dir = tempfile.gettempdir()\noutput_raster = f\"{temp_dir}/weighted_raster_calc.tif\"\n\nexpression = '0.3 * \"{}@1\" + 0.5 * \"{}@1\" + 0.2 * \"{}@1\" '.format(land_cover_layer_name, soil_layer_name, dem_layer_name)\nresult = processing.run(\"qgis:rastercalculator\", {\n    'LAYERS': [land_cover_path, soil_path, dem_path],\n    'EXPRESSION': expression,\n    'EXTENT': None,\n    'CRS': None,\n    'OUTPUT': output_raster\n})\n\noutput_layer = QgsRasterLayer(output_raster, \"Weighted Raster Calculation\")\nif output_layer.isValid():\n    project.addMapLayer(output_layer)"
  },
  {
    "request": "지금 선택한 레이어는 tif 파일이야. \n\n3x3 중간값 필터를 적용해줘.",
    "response": "from qgis.core import QgsProject, QgsRasterLayer\nimport processing\nfrom osgeo import gdal\nimport numpy as np\nimport os, tempfile\nfrom qgis.core import QgsProject, QgsRasterLayer\nimport processing\nfrom osgeo import gdal\nimport numpy as np\nfrom scipy.ndimage import median_filter\nimport os\nimport tempfile\n\nlayer = iface.activeLayer()\ninput_path = layer.dataProvider().dataSourceUri()\nsrc_ds = gdal.Open(input_path)\nif src_ds is None:\n    raise Exception(\"입력 래스터를 열 수 없습니다: {}\".format(input_path))\nnum_bands = src_ds.RasterCount\nfiltered_bands = []\nfor band_index in range(1, num_bands+1):\n    band = src_ds.GetRasterBand(band_index)\n    arr = band.ReadAsArray()\n    filtered_arr = median_filter(arr, size=3)\n    flipped_arr = np.flipud(filtered_arr)\n    filtered_bands.append(flipped_arr)\ntemp_dir = tempfile.gettempdir()\noutput_path = os.path.join(temp_dir, 'median_filtered_rgb.tif')\ndriver = gdal.GetDriverByName('GTiff')\ndst_ds = driver.Create(output_path, src_ds.RasterXSize, src_ds.RasterYSize, num_bands, src_ds.GetRasterBand(1).DataType)\nif dst_ds is None:\n    raise Exception(\"출력 파일을 생성할 수 없습니다: {}\".format(output_path))\ngt = list(src_ds.GetGeoTransform())\nrows = src_ds.RasterYSize\ngt[3] = gt[3] - (rows) * gt[5]\ndst_ds.SetGeoTransform(tuple(gt))\ndst_ds.SetProjection(src_ds.GetProjection())\nfor i, band_array in enumerate(filtered_bands):\n    dst_ds.GetRasterBand(i+1).WriteArray(band_array)\ndst_ds.FlushCache()\ndst_ds = None\nfiltered_layer = QgsRasterLayer(output_path, \"Median Filtered RGB Layer\")\nif filtered_layer.isValid():\n    QgsProject.instance().addMapLayer(filtered_layer)\n    print(\"RGB 영상에 중앙값 필터가 성공적으로 적용되어 추가되었습니다.\")\nelse:\n    print(\"새로운 레이어가 유효하지 않습니다: {}\".format(output_path))\n\n\no3-mini-high"
  },
  {
    "request": "지금 선택한 레이어는 tif 파일이야. \n\n5x5 중간값 필터를 적용해줘.",
    "response": "from qgis.core import QgsProject, QgsRasterLayer\nimport processing\nfrom osgeo import gdal\nimport numpy as np\nimport os, tempfile\nfrom qgis.core import QgsProject, QgsRasterLayer\nimport processing\nfrom osgeo import gdal\nimport numpy as np\nfrom scipy.ndimage import median_filter\nimport os\nimport tempfile\n\nlayer = iface.activeLayer()\ninput_path = layer.dataProvider().dataSourceUri()\nsrc_ds = gdal.Open(input_path)\nif src_ds is None:\n    raise Exception(\"입력 래스터를 열 수 없습니다: {}\".format(input_path))\nnum_bands = src_ds.RasterCount\nfiltered_bands = []\nfor band_index in range(1, num_bands+1):\n    band = src_ds.GetRasterBand(band_index)\n    arr = band.ReadAsArray()\n    filtered_arr = median_filter(arr, size=5)\n    flipped_arr = np.flipud(filtered_arr)\n    filtered_bands.append(flipped_arr)\ntemp_dir = tempfile.gettempdir()\noutput_path = os.path.join(temp_dir, 'median_filtered_rgb.tif')\ndriver = gdal.GetDriverByName('GTiff')\ndst_ds = driver.Create(output_path, src_ds.RasterXSize, src_ds.RasterYSize, num_bands, src_ds.GetRasterBand(1).DataType)\nif dst_ds is None:\n    raise Exception(\"출력 파일을 생성할 수 없습니다: {}\".format(output_path))\ngt = list(src_ds.GetGeoTransform())\nrows = src_ds.RasterYSize\ngt[3] = gt[3] - (rows) * gt[5]\ndst_ds.SetGeoTransform(tuple(gt))\ndst_ds.SetProjection(src_ds.GetProjection())\nfor i, band_array in enumerate(filtered_bands):\n    dst_ds.GetRasterBand(i+1).WriteArray(band_array)\ndst_ds.FlushCache()\ndst_ds = None\nfiltered_layer = QgsRasterLayer(output_path, \"Median Filtered RGB Layer\")\nif filtered_layer.isValid():\n    QgsProject.instance().addMapLayer(filtered_layer)\n    print(\"RGB 영상에 중앙값 필터가 성공적으로 적용되어 추가되었습니다.\")\nelse:\n    print(\"새로운 레이어가 유효하지 않습니다: {}\".format(output_path))\n\n\no3-mini-high"
  },
  {
    "request": "지금 선택한 레이어는 tif 파일이야. 밝기값이 0 이하인 픽셀의 밝기값을 0으로 바꿔줘.",
    "response": "from qgis.core import QgsProject, QgsRasterLayer\nimport processing\nfrom osgeo import gdal\nimport numpy as np\nimport os, tempfile\n\n# 현재 활성 레이어 가져오기 (tif 파일이어야 함)\nlayer = iface.activeLayer()\n\n# 활성 레이어의 데이터 소스 경로 추출\ninput_path = layer.dataProvider().dataSourceUri()\n\n# GDAL을 이용해 입력 래스터 열기\nsrc_ds = gdal.Open(input_path)\nif src_ds is None:\n    raise Exception(\"입력 래스터를 열 수 없습니다: {}\".format(input_path))\n\n# 래스터의 밴드 수 확인 (RGB 또는 다중 밴드 처리)\nnum_bands = src_ds.RasterCount\n\n# 각 밴드를 처리한 결과를 저장할 리스트\nprocessed_bands = []\n\n# 각 밴드별로 데이터 읽어서 0 이하인 픽셀을 0으로 변경하고, 수직 반전 처리\nfor band_idx in range(1, num_bands + 1):\n    band = src_ds.GetRasterBand(band_idx)\n    arr = band.ReadAsArray()\n    # 밝기값이 0 이하인 픽셀을 0으로 설정\n    arr[arr <= 0] = 0\n    # np.flipud를 적용하여 배열을 위아래 반전 (원래 배열의 첫 행과 마지막 행의 순서가 뒤바뀜)\n    arr = np.flipud(arr)\n    processed_bands.append(arr)\n\n# 임시 출력 파일 경로 생성 (GeoTIFF 파일)\ntemp_dir = tempfile.gettempdir()\noutput_path = os.path.join(temp_dir, \"modified_brightness.tif\")\n\n# GeoTIFF 드라이버로 출력 래스터 생성 (원본과 동일한 크기, 밴드 수, 데이터 타입 사용)\ndriver = gdal.GetDriverByName('GTiff')\ndst_ds = driver.Create(output_path, src_ds.RasterXSize, src_ds.RasterYSize, num_bands, src_ds.GetRasterBand(1).DataType)\nif dst_ds is None:\n    raise Exception(\"출력 파일을 생성할 수 없습니다: {}\".format(output_path))\n\n# 원본 래스터의 geotransform을 가져오기\ngt = list(src_ds.GetGeoTransform())\nrows = src_ds.RasterYSize\n# 원본 geotransform의 gt[3]는 top-left Y 좌표인데, np.flipud로 배열을 반전했으므로\n# 새로운 배열의 첫 행은 원래의 마지막 행에 해당합니다.\n# 따라서 새로운 top-left Y 좌표는 원본의 bottom-left 좌표로 설정해야 합니다.\ngt[3] = gt[3] - (rows) * gt[5]\n\ndst_ds.SetGeoTransform(tuple(gt))\ndst_ds.SetProjection(src_ds.GetProjection())\n\n# 각 밴드별로 처리된 배열을 출력 래스터에 기록\nfor i, band_array in enumerate(processed_bands):\n    dst_ds.GetRasterBand(i+1).WriteArray(band_array)\n\ndst_ds.FlushCache()\ndst_ds = None  # 파일 닫기\n\n# QGIS에 새로운 래스터 레이어로 불러오기\nmodified_layer = QgsRasterLayer(output_path, \"Modified Brightness Raster\")\nif modified_layer.isValid():\n    QgsProject.instance().addMapLayer(modified_layer)\n    print(\"수정된 래스터 레이어가 성공적으로 추가되었습니다.\")\nelse:\n    print(\"새로운 레이어가 유효하지 않습니다: {}\".format(output_path))"
  }
]